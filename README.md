Prototype for Substrate client refactoring.

Guidelines for writing code:

- No trait definitions, except for private traits used purely as implementation detail.
- No `Arc`s or `Mutex`es exposed in public APIs.
- No splitting of the crate into multiple crates without a good reason. "Improving compilation time" is not considered a good reason.
- No using the `log`, `tracing`, `slog`, etc. libraries, or any library whose use must be spread through the code base. As an example, `prometheus` is allowed but only in a well-scoped context and by pulling information from the various components, rather than injecting it.
- Do not perform any memory allocation unless the logic of the code you're writing requires storing data for later or passing data between tasks/threads.
- Embrace TODO-driven development. Try as much as possible to write code that will never need to change, but if that isn't possible leave a `// TODO` comment in the code explaining which modifications will be needed in the future. Writing code that will never need to change is still the preferred approach, and it's better to take more time before merging something than merging it with active TODOs.
- Do not apply the DRY principle, in other words don't try to remove duplicated code, without Pierre's approval.

# Objectives compared to Substrate

This code base proposed an opinionated approaches that differ from Substrate.

## Readability

The number one objective of this code base is to conform to the Substrate/Polkadot specs and not have any bug or security issue.

Beyond that, the most important metric of quality of this source code is how easy it is to understand.

The reference point of this metric is the documentation generated by `cargo doc`. It can more or less be seen as cargo-doc-driven development.

In details:

- Code must be properly documented, and the context for why the code exists should be given.
- Examples must be written as much as possible.
- When possible, use types found in the standard library rather than types defined locally or defined in other libraries. For example, always use `[u8; 32]` rather than `H256`.
- Trait definitions are only ever allowed for implementation details. Custom traits **must not** be exposed in any public API.

## Purity

When applicable, code must not have any side effect and must only ever return an output that directly depends on its inputs.

In particular, it must (when applicable) not perform any operation that directly or indirectly requires help from the operating system, such as getting the current time, accessing files, or sleeping the thread.

In details:

- No global variables (except for niche optimizations).
- No thread-local variables (except for niche optimizations).
- Never sleep the current thread. Everything must be asynchronous.
- No logging (no `log` library).

One must strive to make the code compile for `no_std` contexts if theoretically possible. As such, any code that directly or indirectly requires help from the operating system must be optional and disableable at compile-time.

## Reusability: don't mix concerns

Substrate is based on an architecture where each piece of code plays a specific role in a grander vision. The author of substrate-lite considers that this grander vision is too complicated for this kind of architecture.

In substrate-lite, however, almost all the modules of the source code are provided as tools, as if they were small libraries that are available to be used.

For example, features such as Prometheus metrics or the RPC endpoints **must not** be rooted in the code. It **must** be theoretically easy to remove support for this kind of feature from the source code. Prefer *pulling* information from components from a higher-level rather than passing `Arc` objects around.

Other example: the module that verifies whether a block respects the Babe algorithm must be passed as input the information required for this verification, and doesn't try, for example, to load the information from a database. The Babe verification code should only not be concerned with the concept of a database.

While the guidelines here a blurry, here are a few points:

- Dependency injection is almost always a bad thing. As such, any complex trait definition ("complex" here meaning "more complex than the ones found in the standard library such as `Clone` or `Eq`") is forbidden.
- Exposing `Arc`s in your public API is almost always a bad thing.

## Assumption that specs will not change

Substrate is organized around core components that are almost impossible to extract: a database, a client, the networking, a transaction pool, and so on. These components are tightly coupled together.

The blockchain-related logic is plugged on top of these core components and can, however, be changed. One can, for example, remove everything related to the Babe consensus algorithm and replace with by another consensus algorithm.

This project, on the other hand, is implemented following the current state of the Substrate/Polkadot specifications, and assumes that these specifications will never change. This assumption allows, in turn, for better readability and more flexibility when it comes to the purely engineering aspects of the codebase.

For example, the code that decodes block headers in written in a way that would be quite annoying (though straight-forward) to modify if the format of a block header ever changes. However, we simply assume that the format of block headers will rarely, if ever, change.

In particular, there is an assumption that the list of consensus algorithms is known in advance and will rarely change. Substrate-lite prefers the explicitness of code specific to every single consensus code, rather than giving the fake impression to the user that they can simply plug their own algorithm and expect everything to work.

## Fail fast

Code **must not** panic as a result of unexpected input from the user or from the network.

However, code **must** panic if its internal consistency is compromised. In other words, if the only possible reason for the panic is a bug in the logic of the code.

The author of this crate considers that it is dangerous to try to continue running the program if it is known that it does not run according to expectations.

While there is no rule in this source code about `unwrap`, the programmer is expected to think about every single `unwrap()` that they write and is concious that a `None` or an `Err` cannot happen unless a bug is present.
