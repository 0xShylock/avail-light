//! BABE consensus.
//!
//! BABE, or Blind Assignment for Blockchain Extension, is the consensus algorithm used by
//! Polkadot in order to determine who is authorized to generate a block.
//!
//! Every block (with the exception of the genesis block) must contain, in its header, some data
//! that makes it possible to verify that it has been generated by a legitimate author.
//!
//! References:
//!
//! - https://research.web3.foundation/en/latest/polkadot/BABE/Babe.html
//!
//! # Overview of BABE
//!
//! In the BABE algorithm, time is divided into non-overlapping **epochs**, themselves divided
//! into **slots**. How long an epoch and a slot are is determined by calling the
//! `BabeApi_configuration` runtime entry point.
//!
//! > **Note**: As example values, in the Polkadot genesis, a slot lasts for 6 seconds and an
//! >           epoch consists of 2400 slots (in other words, four hours).
//!
//! Every block that is produced must belong to a specific slot. This slot number can be found in
//! the block header, with the exception of the genesis block. Slots are numbered, and the genesis
//! block implicitly belongs to slot 0.
//!
//! The header of first block produced after a transition to a new epoch must contain a log entry
//! indicating the public keys that are allowed to sign blocks, alongside with a weight for each of
//! them, and a "randomness value". This information does not concern the newly-started epoch, but
//! the one immediately after. In other words, the first block of epoch `N` contains the
//! information about epoch `N+1`.
//!
//! > **Note**: The way the list of authorities and their weights is determined is at the
//! >           discretion of the runtime code and is out of scope of this module, but it normally
//! >           corresponds to the list of validators and how much stake is available to them.
//!
//! In order to produce a block, one must generate, using a
//! [VRF (Verifiable Random Function)](https://en.wikipedia.org/wiki/Verifiable_random_function),
//! and based on the slot number, genesis hash, and aformentioned "randomness value",
//! a number whose value is lower than a certain threshold.
//!
//! The number that has been generated must be included in the header of the authored block,
//! alongside with the proof of the correct generation that can be verified using one of the
//! public keys allowed to generate blocks in that epoch. The weight associated to that public key
//! determines the allowed threshold.
//!
//! The "randomess value" of an epoch `N` is calculated by combining the generated numbers of all
//! the blocks of the epoch `N - 2`.
//!
//! ## Secondary slots
//!
//! While all slots can be claimed by generating a number below a certain threshold, each slot is
//! additionally assigned to a specific public key amongst the ones allowed. The owner of a
//! public key is always allowed to generate a block during the slot assigned to it.
//!
//! The mechanism of attributing each slot to a public key is called "secondary slots", while the
//! mechanism of generating a number below a certain threshold is called "primary slots". As their
//! name indicates, primary slots have a higher priority over secondary slots.
//!
//! Secondary slots are a way to guarantee that all slots can potentially lead to a block being
//! produced.
//!
//! ## Chain selection
//!
//! The "best" block of a chain in the BABE algorithm is the one with the highest slot number.
//! If there exists multiple blocks on the same slot, the best block is one with the highest number
//! of primary slots claimed. In other words, if two blocks have the same parent, but one is a
//! primary slot claim and the other is a secondary slot claim, we prefer the one with the primary
//! slot claim.
//!
//! Keep in mind that there can still be draws in terms of primary slot claims count, in which
//! case the winning block is the one upon which the next block author builds upon.
//!
//! ## Epochs 0 and 1
//!
//! The information about an epoch `N` is provided by the first block of the epoch `N-1`.
//!
//! Because of this, we need to special-case epochs 0 and 1. The information about these two
//! epochs in particular is contained in the chain-wide BABE configuration found in the runtime.

use crate::executor;
use parity_scale_codec::DecodeAll as _;

mod definitions;
mod runtime;

pub mod chain_config;
//pub mod header_info;

pub use chain_config::BabeGenesisConfiguration;

/// Failure to verify a block.
#[derive(Debug, Clone, derive_more::Display)]
pub enum VerifyError {
    /*/// Error while reading information from the header.
BadHeader(header_info::Error),*/}

/// Configuration for [`verify_header`].
pub struct VerifyConfig<'a> {
    /// SCALE-encoded header of the block.
    pub scale_encoded_header: &'a [u8],

    /// BABE configuration retrieved from the genesis block.
    ///
    /// Can be obtained by calling [`BabeGenesisConfiguration::from_virtual_machine_prototype`]
    /// with the runtime of the genesis block.
    pub genesis_configuration: &'a BabeGenesisConfiguration,
}

/// Verifies whether a block header provides a correct proof of the legitimacy of the authorship.
pub fn verify_header(config: VerifyConfig) -> Result<(), VerifyError> {
    let _header = crate::header::decode(config.scale_encoded_header).unwrap();

    /*let header_info = header_info::header_information(config.scale_encoded_header)
        .map_err(VerifyError::BadHeader)?;

    if !consensus_logs.is_empty() {
        println!("logs: {:?}", consensus_logs);
    }*/

    // TODO:
    Ok(())
}
