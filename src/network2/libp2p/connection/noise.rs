use alloc::collections::VecDeque;
use core::{cmp, convert::TryFrom as _, fmt, iter};
use libp2p::PeerId;
use prost::Message as _;

mod payload_proto {
    // File generated by the build script.
    include!(concat!(env!("OUT_DIR"), "/payload.proto.rs"));
}

/// The noise key is the key exchanged during the noise handshake. It is *not* the same as the
/// libp2p key. The libp2p key is used only to sign the noise public key, while the ECDH is
/// performed with the noise key.
///
/// The noise key is typically generated at startup and doesn't have to be persisted.
///
/// In order to generate a [`NoiseKey`], two things are needed:
///
/// - A public/private key, also represented as [`UnsignedNoiseKey`].
/// - A signature of this public key made using the libp2p private key.
///
pub struct NoiseKey {
    key: snow::Keypair,
    /// Handshake to encrypt then send on the wire.
    handshake_message: Vec<u8>,
}

impl NoiseKey {
    /// Generates a new private and public key pair signed with the given libp2p ed25519 key.
    pub fn new(libp2p_ed25519_private_key: &[u8; 32]) -> Self {
        let unsigned = UnsignedNoiseKey::new();

        let (libp2p_public_key, signature) = {
            // Creating a `SecretKey` can fail only if the length isn't 32 bytes.
            let secret = ed25519_dalek::SecretKey::from_bytes(libp2p_ed25519_private_key).unwrap();
            let expanded = ed25519_dalek::ExpandedSecretKey::from(&secret);
            let public = ed25519_dalek::PublicKey::from(&expanded);
            // TODO: use sign_prehashed or sign_vectored (https://github.com/dalek-cryptography/ed25519-dalek/pull/143) to not allocate Vec
            let signature = expanded.sign(&unsigned.payload_to_sign_as_vec(), &public);
            (public, signature)
        };

        unsigned.sign(libp2p_public_key.to_bytes(), signature.to_bytes())
    }
}

/// Prototype for a [`NoiseKey`].
///
/// This type is provided for situations where the user has access to some signing mechanism,
/// such as a hardware device, but not directly to the private key.
///
/// For simple cases, prefer using [`NoiseKey::new`].
pub struct UnsignedNoiseKey {
    key: snow::Keypair,
}

impl UnsignedNoiseKey {
    /// Generates a new private and public key pair.
    pub fn new() -> Self {
        UnsignedNoiseKey {
            // TODO: can panic if there's no RNG; do we care about that?
            key: snow::Builder::new(NOISE_PARAMS.clone())
                .generate_keypair()
                .unwrap(),
        }
    }

    /// Returns the data that has to be signed.
    pub fn payload_to_sign<'a>(&'a self) -> impl Iterator<Item = impl AsRef<[u8]> + 'a> + 'a {
        iter::once(&b"noise-libp2p-static-key:"[..]).chain(iter::once(&self.key.public[..]))
    }

    /// Returns the data that has to be signed.
    ///
    /// This method is a more convenient equivalent to
    /// [`UnsignedNoiseKey::payload_to_sign_as_vec`].
    pub fn payload_to_sign_as_vec(&self) -> Vec<u8> {
        self.payload_to_sign().fold(Vec::new(), |mut a, b| {
            a.extend_from_slice(b.as_ref());
            a
        })
    }

    /// Turns this [`UnsignedNoiseKey`] into a [`NoiseKey`] after signing it using the libp2p
    /// private key.
    pub fn sign(self, libp2p_public_ed25519_key: [u8; 32], signature: [u8; 64]) -> NoiseKey {
        let libp2p_pubkey_protobuf = libp2p::identity::PublicKey::Ed25519(
            libp2p::identity::ed25519::PublicKey::decode(&libp2p_public_ed25519_key).unwrap(),
        )
        .into_protobuf_encoding();

        let handshake_message = {
            let mut protobuf = payload_proto::NoiseHandshakePayload::default();
            protobuf.identity_key = libp2p_pubkey_protobuf;
            protobuf.identity_sig = signature.to_vec();

            let mut msg = Vec::with_capacity(protobuf.encoded_len());
            protobuf.encode(&mut msg).unwrap();
            msg
        };

        NoiseKey {
            key: self.key,
            handshake_message,
        }
    }
}

pub struct Noise {
    inner: snow::TransportState,

    /// Buffer of data containing data received on the wire, before decryption.
    rx_buffer_encrypted: Vec<u8>,

    /// Buffer of data containing data received on the wire, after decryption.
    rx_buffer_decrypted: Vec<u8>,

    /// Buffer of data containing data received on the wire, after encryption.
    tx_buffer_encrypted: VecDeque<u8>,
}

impl Noise {
    /// Feeds data received from the wire.
    pub fn inject_inbound_data(&mut self, payload: &[u8]) {
        // TODO: possibly optimize by not always copy bytes to `rx_buffer_encrypted`
        self.rx_buffer_encrypted.extend(payload.iter().cloned());

        self.rx_buffer_decrypted.resize(payload.len(), 0);
        let _written = self
            .inner
            .read_message(payload, &mut self.rx_buffer_decrypted);
        // TODO: continue
        // TODO: check _written
    }

    ///
    /// > **Note**: You are encouraged to not call this method with small payloads, as at least
    /// >           two bytes of data are added to the stream every time this method is called.
    // TODO: docs
    pub fn inject_outbound_data(&mut self, payload: &[u8]) {
        // The maximum size of a noise message is 65535 bytes. As such, we split any payload that
        // is longer than that.
        for payload in payload.chunks(65535) {
            debug_assert!(payload.is_empty()); // guaranteed by `chunks()`

            // The complexity below stems from the fact that we write into a `VecDeque`.

            // TODO: review; might be wrong

            let out_buf_len_before = self.tx_buffer_encrypted.len();
            self.tx_buffer_encrypted
                .resize(out_buf_len_before + 2 + payload.len(), 0);

            let payload_len_bytes = u16::try_from(payload.len()).unwrap().to_be_bytes();
            self.tx_buffer_encrypted[out_buf_len_before] = payload_len_bytes[0];
            self.tx_buffer_encrypted[out_buf_len_before + 1] = payload_len_bytes[1];

            let mut out_buf_slices = self.tx_buffer_encrypted.as_mut_slices();
            out_buf_slices.1 =
                &mut out_buf_slices.1[out_buf_len_before.saturating_sub(out_buf_slices.0.len())..];
            out_buf_slices.0 = {
                let off = out_buf_slices.0.len().saturating_sub(out_buf_len_before);
                &mut out_buf_slices.0[off..]
            };

            let to_write0 = cmp::min(out_buf_slices.0.len(), payload.len());
            debug_assert!(payload.len().saturating_sub(to_write0) <= out_buf_slices.1.len());

            let _written = self
                .inner
                .write_message(&payload[..to_write0], out_buf_slices.0)
                .unwrap();
            debug_assert_eq!(_written, to_write0);

            if to_write0 != payload.len() {
                let _written = self
                    .inner
                    .write_message(&payload[to_write0..], out_buf_slices.1)
                    .unwrap();
                debug_assert_eq!(_written, out_buf_slices.1.len().saturating_sub(to_write0));
            }
        }
    }

    /// Write to the given buffer the bytes that are ready to be sent out. Returns the number of
    /// bytes written to `destination`.
    pub fn write_out(&mut self, mut destination: &mut [u8]) -> usize {
        let mut total_written = 0;

        loop {
            let to_write = self.tx_buffer_encrypted.as_slices().0;
            let to_write_len = cmp::min(to_write.len(), destination.len());
            destination[..to_write_len].copy_from_slice(&to_write[..to_write_len]);
            for _ in 0..to_write_len {
                let _ = self.tx_buffer_encrypted.pop_front();
            }
            total_written += to_write_len;
            destination = &mut destination[to_write_len..];
        }

        total_written
    }
}

impl fmt::Debug for Noise {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("Noise").finish()
    }
}

/// State of a Noise handshake.
#[derive(Debug)]
pub enum NoiseHandshake {
    /// Handshake still in progress. More data needs to be sent or received.
    InProgress(InProgress),
    /// Noise handshake has successfully completed.
    Success {
        /// Object to use to encrypt and decrypt all further communications.
        cipher: Noise,
        /// [`PeerId`] of the remote.
        remote_peer_id: PeerId,
    },
}

/// Handshake still in progress. More data needs to be sent or received.
pub struct InProgress {
    inner: snow::HandshakeState,

    /// Buffer of data containing data received on the wire, before decryption.
    rx_buffer_encrypted: Vec<u8>,

    /// Buffer of data containing data received on the wire, after decryption.
    rx_buffer_decrypted: Vec<u8>,

    /// Buffer of data containing data received on the wire, after encryption.
    tx_buffer_encrypted: VecDeque<u8>,
}

impl NoiseHandshake {
    pub fn new(key: &NoiseKey, endpoint: Endpoint) -> Self {
        NoiseHandshake::InProgress(InProgress::new(key, endpoint))
    }
}

impl InProgress {
    pub fn new(key: &NoiseKey, endpoint: Endpoint) -> Self {
        let inner = {
            let builder =
                snow::Builder::new(NOISE_PARAMS.clone()).local_private_key(&key.key.private);
            match endpoint {
                Endpoint::Initiator => builder.build_initiator(),
                Endpoint::Responder => builder.build_responder(),
            }
            .unwrap()
        };

        let mut tx_buffer_encrypted = VecDeque::new();
        tx_buffer_encrypted.resize(key.handshake_message.len() + 256, 0);
        debug_assert!(tx_buffer_encrypted.as_slices().1.is_empty());
        let written = inner
            .write_message(
                &key.handshake_message,
                tx_buffer_encrypted.as_mut_slices().0,
            )
            .unwrap();
        assert!(written < tx_buffer_encrypted.len()); // be sure that the message has fit into `out`.
        tx_buffer_encrypted.truncate(written);

        InProgress {
            inner,
            rx_buffer_encrypted: Vec::new(), // TODO: with_capacity?
            rx_buffer_decrypted: Vec::new(),
            tx_buffer_encrypted,
        }
    }

    /// Feeds data received from the wire.
    pub fn inject_data(
        mut self,
        mut payload: &[u8],
    ) -> Result<(NoiseHandshake, usize), HandshakeError> {
        let mut total_read = 0;

        // Handshake message must start with two bytes of length.
        // Copy bytes one by one from payload until we reach a length of two.
        while self.rx_buffer_encrypted.len() < 2 {
            if payload.is_empty() {
                return Ok((NoiseHandshake::InProgress(self), total_read));
            }

            self.rx_buffer_encrypted.push(payload[0]);
            payload = &payload[1..];
            total_read += 1;
        }

        // Decoding the first two bytes, which are the length of the handshake message.
        let expected_len =
            u16::from_le_bytes(<[u8; 2]>::try_from(&self.rx_buffer_encrypted[..2]).unwrap());
        debug_assert!(self.rx_buffer_encrypted.len() < 2 + usize::from(expected_len));

        // Copy as much data as possible from `payload` to `self.rx_buffer_encrypted`, without
        // copying more than the handshake message.
        let to_copy = cmp::min(
            usize::from(expected_len) + 2 - self.rx_buffer_encrypted.len(),
            payload.len(),
        );
        self.rx_buffer_encrypted
            .extend_from_slice(&payload[..to_copy]);
        debug_assert!(self.rx_buffer_encrypted.len() <= usize::from(expected_len) + 2);
        payload = &payload[to_copy..];
        total_read += to_copy;

        // Return early if the entire handshake message has not been received yet.
        if self.rx_buffer_encrypted.len() < usize::from(expected_len) + 2 {
            return Ok((NoiseHandshake::InProgress(self), total_read));
        }

        // Entire handshake message has been received.
        // Decoding it into `decoded_handshake`.
        let decoded_handshake = {
            // The decrypted message can only ever be smaller than the encrypted message. As such,
            // we allocate a buffer of size equal to the encrypted message.
            let mut decoded = vec![0; usize::from(expected_len)];
            match self
                .inner
                .read_message(&self.rx_buffer_encrypted[2..], &mut decoded)
            {
                Err(err) => {
                    return Err(HandshakeError::Cipher(CipherError(err)));
                }
                Ok(n) => {
                    debug_assert!(n <= decoded.len());
                    decoded.truncate(n);
                }
            }
            decoded
        };

        // The decoded handshake is a protobuf message.
        let mut handshake_payload =
            match payload_proto::NoiseHandshakePayload::decode(&decoded_handshake[..]) {
                Ok(p) => p,
                Err(err) => {
                    return Err(HandshakeError::HandshakeDecode(HandshakeDecodeError(err)));
                }
            };

        let remote_public_key =
            libp2p::identity::PublicKey::from_protobuf_encoding(&handshake_payload.identity_key)
                .map_err(|_| HandshakeError::InvalidKey)?;

        let cipher = self
            .inner
            .into_transport_mode()
            .map_err(CipherError)
            .map_err(HandshakeError::Cipher)?;

        // TODO: /!\ must verify the signature /!\
        // TODO: id_pk.verify(&[b"noise-libp2p-static-key:", dh_pk.as_ref()].concat(), s)

        self.rx_buffer_encrypted.clear();
        self.rx_buffer_decrypted.clear();
        self.tx_buffer_encrypted.clear();

        Ok((
            NoiseHandshake::Success {
                cipher: Noise {
                    inner: cipher,
                    rx_buffer_encrypted: self.rx_buffer_encrypted,
                    rx_buffer_decrypted: self.rx_buffer_decrypted,
                    tx_buffer_encrypted: self.tx_buffer_encrypted,
                },
                remote_peer_id: remote_public_key.into_peer_id(),
            },
            total_read,
        ))
    }

    /// Write to the given buffer the bytes that are ready to be sent out. Returns the new state
    /// of the handshake, and the number of bytes written to `destination`.
    pub fn write_out(mut self, mut destination: &mut [u8]) -> (NoiseHandshake, usize) {
        let mut total_written = 0;

        loop {
            let to_write = self.tx_buffer_encrypted.as_slices().0;
            let to_write_len = cmp::min(to_write.len(), destination.len());
            destination[..to_write_len].copy_from_slice(&to_write[..to_write_len]);
            for _ in 0..to_write_len {
                let _ = self.tx_buffer_encrypted.pop_front();
            }
            total_written += to_write_len;
            destination = &mut destination[to_write_len..];
        }

        // TODO: call is_handshake_finished()

        (NoiseHandshake::InProgress(self), total_written)
    }
}

impl fmt::Debug for InProgress {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("InProgress").finish()
    }
}

lazy_static::lazy_static! {
    static ref NOISE_PARAMS: snow::params::NoiseParams =
        "Noise_XX_25519_ChaChaPoly_SHA256".parse().unwrap();
}

#[derive(Debug, Copy, Clone)]
pub enum Endpoint {
    Initiator,
    Responder,
}

#[derive(Debug, derive_more::Display)]
pub enum HandshakeError {
    Cipher(CipherError),
    HandshakeDecode(HandshakeDecodeError),
    InvalidKey,
}

/// Error while decoding data.
#[derive(Debug, derive_more::Display)]
pub struct CipherError(snow::Error);

/// Error while decoding the handshake.
#[derive(Debug, derive_more::Display)]
pub struct HandshakeDecodeError(prost::DecodeError);
