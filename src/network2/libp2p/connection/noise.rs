use alloc::collections::VecDeque;
use core::{cmp, convert::TryFrom as _, fmt, iter};
use libp2p::PeerId;
use prost::Message as _;

mod payload_proto {
    // File generated by the build script.
    include!(concat!(env!("OUT_DIR"), "/payload.proto.rs"));
}

/// The noise key is the key exchanged during the noise handshake. It is **not** the same as the
/// libp2p key. The libp2p key is used only to sign the noise public key, while the ECDH is
/// performed with the noise key.
///
/// The noise key is typically generated at startup and doesn't have to be persisted on disk.
///
/// In order to generate a [`NoiseKey`], two things are needed:
///
/// - A public/private key, also represented as [`UnsignedNoiseKey`].
/// - A signature of this public key made using the libp2p private key.
///
/// The signature requires access to the libp2p private key. As such, there are two possible
/// ways to create a [`NoiseKey`]:
///
/// - The easier way, by passing the libp2p private key to [`NoiseKey::new`].
/// - The slightly more complex way, by first creating an [`UnsignedNoiseKey`] then passing a
/// a signature. This second method doesn't require direct access to the private key, but only
/// to a method to sign a message, for example a hardware device.
///
pub struct NoiseKey {
    key: snow::Keypair,
    /// Handshake to encrypt then send on the wire.
    handshake_message: Vec<u8>,
}

impl NoiseKey {
    /// Generates a new private and public key pair signed with the given libp2p ed25519 key.
    pub fn new(libp2p_ed25519_private_key: &[u8; 32]) -> Self {
        let unsigned = UnsignedNoiseKey::new();

        let (libp2p_public_key, signature) = {
            // Creating a `SecretKey` can fail only if the length isn't 32 bytes.
            let secret = ed25519_dalek::SecretKey::from_bytes(libp2p_ed25519_private_key).unwrap();
            let expanded = ed25519_dalek::ExpandedSecretKey::from(&secret);
            let public = ed25519_dalek::PublicKey::from(&expanded);
            // TODO: use sign_prehashed or sign_vectored (https://github.com/dalek-cryptography/ed25519-dalek/pull/143) to not allocate Vec
            let signature = expanded.sign(&unsigned.payload_to_sign_as_vec(), &public);
            (public, signature)
        };

        unsigned.sign(libp2p_public_key.to_bytes(), signature.to_bytes())
    }
}

/// Prototype for a [`NoiseKey`].
///
/// This type is provided for situations where the user has access to some signing mechanism,
/// such as a hardware device, but not directly to the private key.
///
/// For simple cases, prefer using [`NoiseKey::new`].
pub struct UnsignedNoiseKey {
    key: snow::Keypair,
}

impl UnsignedNoiseKey {
    /// Generates a new private and public key pair.
    pub fn new() -> Self {
        UnsignedNoiseKey {
            // TODO: can panic if there's no RNG; do we care about that?
            key: snow::Builder::new(NOISE_PARAMS.clone())
                .generate_keypair()
                .unwrap(),
        }
    }

    /// Returns the data that has to be signed.
    pub fn payload_to_sign<'a>(&'a self) -> impl Iterator<Item = impl AsRef<[u8]> + 'a> + 'a {
        iter::once("noise-libp2p-static-key:".as_bytes()).chain(iter::once(&self.key.public[..]))
    }

    /// Returns the data that has to be signed.
    ///
    /// This method is a more convenient equivalent to
    /// [`UnsignedNoiseKey::payload_to_sign_as_vec`].
    pub fn payload_to_sign_as_vec(&self) -> Vec<u8> {
        self.payload_to_sign().fold(Vec::new(), |mut a, b| {
            a.extend_from_slice(b.as_ref());
            a
        })
    }

    /// Turns this [`UnsignedNoiseKey`] into a [`NoiseKey`] after signing it using the libp2p
    /// private key.
    pub fn sign(self, libp2p_public_ed25519_key: [u8; 32], signature: [u8; 64]) -> NoiseKey {
        let libp2p_pubkey_protobuf = libp2p::identity::PublicKey::Ed25519(
            libp2p::identity::ed25519::PublicKey::decode(&libp2p_public_ed25519_key).unwrap(),
        )
        .into_protobuf_encoding();

        let handshake_message = {
            let mut protobuf = payload_proto::NoiseHandshakePayload::default();
            protobuf.identity_key = libp2p_pubkey_protobuf;
            protobuf.identity_sig = signature.to_vec();

            let mut msg = Vec::with_capacity(protobuf.encoded_len());
            protobuf.encode(&mut msg).unwrap();
            msg
        };

        NoiseKey {
            key: self.key,
            handshake_message,
        }
    }
}

pub struct Noise {
    inner: snow::TransportState,

    /// Buffer of data containing data received on the wire, before decryption.
    rx_buffer_encrypted: Vec<u8>,

    /// Buffer of data containing data received on the wire, after decryption.
    rx_buffer_decrypted: Vec<u8>,

    /// Buffer of data containing data to be sent on the wire, after encryption and with the
    /// length delimiters.
    tx_buffer_encrypted: VecDeque<u8>,
}

impl Noise {
    /// Feeds data received from the wire.
    pub fn inject_inbound_data(&mut self, payload: &[u8]) {
        // TODO: possibly optimize by not always copy bytes to `rx_buffer_encrypted`
        self.rx_buffer_encrypted.extend(payload.iter().cloned());

        self.rx_buffer_decrypted.resize(payload.len(), 0);
        let _written = self
            .inner
            .read_message(payload, &mut self.rx_buffer_decrypted);
        // TODO: continue
        // TODO: check _written
    }

    ///
    /// > **Note**: You are encouraged to not call this method with small payloads, as at least
    /// >           two bytes of data are added to the stream every time this method is called.
    // TODO: docs
    pub fn inject_outbound_data(&mut self, payload: &[u8]) {
        // The maximum size of a noise message is 65535 bytes. As such, we split any payload that
        // is longer than that.
        for payload in payload.chunks(65535) {
            debug_assert!(payload.is_empty()); // guaranteed by `chunks()`

            // The complexity below stems from the fact that we write into a `VecDeque`.

            // TODO: review; might be wrong

            let out_buf_len_before = self.tx_buffer_encrypted.len();
            self.tx_buffer_encrypted
                .resize(out_buf_len_before + 2 + payload.len(), 0);

            let payload_len_bytes = u16::try_from(payload.len()).unwrap().to_be_bytes();
            self.tx_buffer_encrypted[out_buf_len_before] = payload_len_bytes[0];
            self.tx_buffer_encrypted[out_buf_len_before + 1] = payload_len_bytes[1];

            let mut out_buf_slices = self.tx_buffer_encrypted.as_mut_slices();
            out_buf_slices.1 =
                &mut out_buf_slices.1[out_buf_len_before.saturating_sub(out_buf_slices.0.len())..];
            out_buf_slices.0 = {
                let off = out_buf_slices.0.len().saturating_sub(out_buf_len_before);
                &mut out_buf_slices.0[off..]
            };

            let to_write0 = cmp::min(out_buf_slices.0.len(), payload.len());
            debug_assert!(payload.len().saturating_sub(to_write0) <= out_buf_slices.1.len());

            let _written = self
                .inner
                .write_message(&payload[..to_write0], out_buf_slices.0)
                .unwrap();
            debug_assert_eq!(_written, to_write0);

            if to_write0 != payload.len() {
                let _written = self
                    .inner
                    .write_message(&payload[to_write0..], out_buf_slices.1)
                    .unwrap();
                debug_assert_eq!(_written, out_buf_slices.1.len().saturating_sub(to_write0));
            }
        }
    }

    /// Write to the given buffer the bytes that are ready to be sent out. Returns the number of
    /// bytes written to `destination`.
    pub fn write_out(&mut self, mut destination: &mut [u8]) -> usize {
        let mut total_written = 0;

        loop {
            let to_write = self.tx_buffer_encrypted.as_slices().0;
            let to_write_len = cmp::min(to_write.len(), destination.len());
            destination[..to_write_len].copy_from_slice(&to_write[..to_write_len]);
            for _ in 0..to_write_len {
                let _ = self.tx_buffer_encrypted.pop_front();
            }
            total_written += to_write_len;
            destination = &mut destination[to_write_len..];
        }

        total_written
    }
}

impl fmt::Debug for Noise {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("Noise").finish()
    }
}

/// State of a Noise handshake.
#[derive(Debug)]
pub enum NoiseHandshake {
    /// Handshake still in progress. More data needs to be sent or received.
    InProgress(HandshakeInProgress),
    /// Noise handshake has successfully completed.
    Success {
        /// Object to use to encrypt and decrypt all further communications.
        cipher: Noise,
        /// [`PeerId`] of the remote.
        remote_peer_id: PeerId,
    },
}

/// Handshake still in progress. More data needs to be sent or received.
pub struct HandshakeInProgress {
    /// Underlying noise state machine.
    ///
    /// Libp2p always uses the XX handshake.
    ///
    /// While the `snow` library ensures that the emitted and received messages respect the
    /// handshake according to the noise specifications, libp2p extends these noise specifications
    /// with a payload that must be transmitted on the second and third messages of the exchange.
    /// This payload must contain a signature of the noise key made using the libp2p key and can
    /// be found in the `tx_payload` field.
    inner: snow::HandshakeState,

    /// Unencrypted payload to send as part of the handshake.
    /// If the payload has already been sent, contains `None`.
    /// If the payload hasn't been sent yet, contains the index of the call to
    /// [`snow::HandshakeState::write_message`] that must contain the payload.
    tx_payload: Option<(usize, Box<[u8]>)>,

    /// State of the remote payload reception.
    rx_payload: RxPayload,

    /// Number of messages remaining to be received. Used to know whether an incoming packet is
    /// still part of the handshake or not.
    rx_messages_remain: usize,

    /// Buffer of data containing data received on the wire, before decryption.
    rx_buffer_encrypted: Vec<u8>,

    /// Buffer of data containing data waiting to be sent on the wire, after encryption. Includes
    /// the length prefixes.
    tx_buffer_encrypted: VecDeque<u8>,
}

enum RxPayload {
    /// Remote payload has been received.
    Received(PeerId),
    /// Index of the call to [`snow::HandshakeState::read_message`], from now, that is expected
    /// to contains the payload.
    NthMessage(usize),
}

impl NoiseHandshake {
    /// Shortcut function that calls [`HandshakeInProgress::new`] and wraps it into a
    /// [`NoiseHandshake`].
    pub fn new(key: &NoiseKey, is_initiator: bool) -> Self {
        NoiseHandshake::InProgress(HandshakeInProgress::new(key, is_initiator))
    }
}

impl HandshakeInProgress {
    /// Initializes a new noise handshake state machine.
    pub fn new(key: &NoiseKey, is_initiator: bool) -> Self {
        let inner = {
            let builder =
                snow::Builder::new(NOISE_PARAMS.clone()).local_private_key(&key.key.private);
            if is_initiator {
                builder.build_initiator()
            } else {
                builder.build_responder()
            }
            .unwrap()
        };

        // Configure according to the XX handshake.
        let (tx_payload, rx_payload, rx_messages_remain) = if is_initiator {
            let tx = Some((1, key.handshake_message.clone().into_boxed_slice()));
            let rx = RxPayload::NthMessage(0);
            (tx, rx, 1)
        } else {
            let tx = Some((0, key.handshake_message.clone().into_boxed_slice()));
            let rx = RxPayload::NthMessage(1);
            (tx, rx, 2)
        };

        let mut handshake = HandshakeInProgress {
            inner,
            tx_payload,
            rx_payload,
            rx_messages_remain,
            rx_buffer_encrypted: Vec::with_capacity(65536 + 2),
            tx_buffer_encrypted: VecDeque::new(),
        };

        handshake.update_message_write();
        handshake
    }

    /// Calls [`snow::HandshakeState::write_message`] if necessary, updates all the internal state,
    /// and puts the message into `tx_buffer_encrypted`.
    fn update_message_write(&mut self) {
        if !self.inner.is_my_turn() {
            return;
        }

        debug_assert!(self.tx_buffer_encrypted.is_empty());

        let payload = match &mut self.tx_payload {
            None => None,
            Some((n, _)) if *n != 0 => {
                *n -= 1;
                None
            }
            opt @ Some(_) => {
                let (_n, payload) = opt.take().unwrap();
                debug_assert_eq!(_n, 0);
                Some(payload)
            }
        };

        self.tx_buffer_encrypted.resize(512, 0);
        debug_assert!(self.tx_buffer_encrypted.as_slices().1.is_empty());
        let written = self
            .inner
            .write_message(
                payload.as_ref().map(|p| &p[..]).unwrap_or(&[]),
                self.tx_buffer_encrypted.as_mut_slices().0,
            )
            .unwrap();
        assert!(written < self.tx_buffer_encrypted.len()); // be sure that the message has fit into `out`.
        self.tx_buffer_encrypted.truncate(written);

        // Handshake must also be prefixed with two bytes indicating its length.
        // The message is guaranteed by the Noise specs to not be more than 64kiB.
        let length_bytes = u16::try_from(self.tx_buffer_encrypted.len())
            .unwrap()
            .to_be_bytes();
        self.tx_buffer_encrypted.push_front(length_bytes[1]);
        self.tx_buffer_encrypted.push_front(length_bytes[0]);
    }

    /// Try to turn this [`InProgress`] into a [`NoiseHandshake::Success`] if possible.
    fn try_finish(mut self) -> NoiseHandshake {
        if !self.tx_buffer_encrypted.is_empty() {
            return NoiseHandshake::InProgress(self);
        }

        if !self.inner.is_handshake_finished() {
            return NoiseHandshake::InProgress(self);
        }

        // If `rx_buffer_encrypted` wasn't empty, that would mean there would still be a buffer
        // to decode.
        debug_assert!(self.rx_buffer_encrypted.is_empty());

        // `into_transport_mode()` can only panic if `!is_handshake_finished()`.
        let cipher = self.inner.into_transport_mode().unwrap();

        let remote_peer_id = match self.rx_payload {
            RxPayload::Received(peer_id) => peer_id,
            // Since `is_handshake_finished()` has returned true, all messages have been
            // exchanged. As such, the remote payload cannot be in a "still waiting to come"
            // situation other than because of logic error within the code.
            RxPayload::NthMessage(_) => unreachable!(),
        };

        NoiseHandshake::Success {
            cipher: Noise {
                inner: cipher,
                rx_buffer_encrypted: self.rx_buffer_encrypted,
                rx_buffer_decrypted: Vec::new(), // TODO: with_capacity
                tx_buffer_encrypted: self.tx_buffer_encrypted,
            },
            remote_peer_id,
        }
    }

    /// Feeds data received from the wire.
    ///
    /// Returns an error in case of protocol error. Otherwise, returns the new state of the
    /// handshake and the number of bytes from `payload` that have been processed.
    ///
    /// If the number of bytes read is different from 0, you should immediately call this method
    /// again with the remaining data.
    pub fn inject_data(
        mut self,
        mut payload: &[u8],
    ) -> Result<(NoiseHandshake, usize), HandshakeError> {
        // Check if incoming data is still part of the handshake.
        // If not, return early without reading anything.
        if self.rx_messages_remain == 0 {
            return Ok((NoiseHandshake::InProgress(self), 0));
        }

        let mut total_read = 0;

        // Handshake message must start with two bytes of length.
        // Copy bytes one by one from payload until we reach a length of two.
        while self.rx_buffer_encrypted.len() < 2 {
            if payload.is_empty() {
                return Ok((NoiseHandshake::InProgress(self), total_read));
            }

            self.rx_buffer_encrypted.push(payload[0]);
            payload = &payload[1..];
            total_read += 1;
        }

        // Decoding the first two bytes, which are the length of the handshake message.
        let expected_len =
            u16::from_be_bytes(<[u8; 2]>::try_from(&self.rx_buffer_encrypted[..2]).unwrap());
        debug_assert!(self.rx_buffer_encrypted.len() < 2 + usize::from(expected_len));

        // Copy as much data as possible from `payload` to `self.rx_buffer_encrypted`, without
        // copying more than the handshake message.
        let to_copy = cmp::min(
            usize::from(expected_len) + 2 - self.rx_buffer_encrypted.len(),
            payload.len(),
        );
        self.rx_buffer_encrypted
            .extend_from_slice(&payload[..to_copy]);
        debug_assert!(self.rx_buffer_encrypted.len() <= usize::from(expected_len) + 2);
        payload = &payload[to_copy..];
        total_read += to_copy;

        // Return early if the entire handshake message has not been received yet.
        if self.rx_buffer_encrypted.len() < usize::from(expected_len) + 2 {
            return Ok((NoiseHandshake::InProgress(self), total_read));
        }

        // Entire handshake message has been received.
        // Decoding the potential payload into `decoded_payload`.
        let decoded_payload = {
            // The decrypted payload can only ever be smaller than the encrypted message. As such,
            // we allocate a buffer of size equal to the encrypted message.
            let mut decoded = vec![0; usize::from(expected_len)];
            match self
                .inner
                .read_message(&self.rx_buffer_encrypted[2..], &mut decoded)
            {
                Err(err) => {
                    return Err(HandshakeError::Cipher(CipherError(err)));
                }
                Ok(n) => {
                    debug_assert!(n <= decoded.len());
                    decoded.truncate(n);
                }
            }
            decoded
        };

        // Data in `rx_buffer_encrypted` has been fully decoded and can be thrown away.
        self.rx_buffer_encrypted.clear();
        self.rx_messages_remain -= 1;

        // Check and update the status of the payload reception.
        let payload_expected = match &mut self.rx_payload {
            RxPayload::NthMessage(0) => true,
            RxPayload::NthMessage(n) => {
                *n -= 1;
                false
            }
            RxPayload::Received(_) => false,
        };

        if payload_expected {
            // The decoded handshake is a protobuf message.
            // Because rust-libp2p was erroneously putting a length prefix before the payload,
            // we try, as a fallback, to skip the first two bytes.
            // See https://github.com/libp2p/rust-libp2p/blob/9178459cc8abb8379c759c02185175af7cfcea78/protocols/noise/src/io/handshake.rs#L368-L384
            // TODO: remove this hack in the future
            let mut handshake_payload =
                match payload_proto::NoiseHandshakePayload::decode(&decoded_payload[..]) {
                    Ok(p) => p,
                    Err(err) if decoded_payload.len() >= 2 => {
                        match payload_proto::NoiseHandshakePayload::decode(&decoded_payload[2..]) {
                            Ok(p) => p,
                            Err(err) => {
                                return Err(HandshakeError::PayloadDecode(PayloadDecodeError(err)));
                            }
                        }
                    }
                    Err(err) => {
                        return Err(HandshakeError::PayloadDecode(PayloadDecodeError(err)));
                    }
                };

            let remote_public_key = libp2p::identity::PublicKey::from_protobuf_encoding(
                &handshake_payload.identity_key,
            )
            .map_err(|_| HandshakeError::InvalidKey)?;

            // Assuming that the libp2p+noise specifications are well-designed, the payload will
            // only arrive after `get_remote_static` is `Some`. Since we have already checked that
            // the payload arrives when it is supposed to, this can never panic.
            let remote_noise_static = self.inner.get_remote_static().unwrap();
            if !remote_public_key.verify(
                &["noise-libp2p-static-key:".as_bytes(), remote_noise_static].concat(),
                &handshake_payload.identity_sig,
            ) {
                return Err(HandshakeError::SignatureVerificationFailed);
            }

            self.rx_payload = RxPayload::Received(remote_public_key.into_peer_id());
        } else if !decoded_payload.is_empty() {
            return Err(HandshakeError::UnexpectedPayload);
        };

        // Now that a message has been received, check if it's the turn of the local node to send
        // something.
        self.update_message_write();

        // Call `try_finish` to check whether the handshake has finished.
        Ok((self.try_finish(), total_read))
    }

    /// Write to the given buffer the bytes that are ready to be sent out. Returns the new state
    /// of the handshake, and the number of bytes written to `destination`.
    pub fn write_out(mut self, mut destination: &mut [u8]) -> (NoiseHandshake, usize) {
        let mut total_written = 0;

        // Copy data from `self.tx_buffer_encrypted` to `destination`.
        loop {
            debug_assert!(
                !self.tx_buffer_encrypted.as_slices().0.is_empty()
                    || self.tx_buffer_encrypted.as_slices().1.is_empty()
            );

            let to_write = self.tx_buffer_encrypted.as_slices().0;
            let to_write_len = cmp::min(to_write.len(), destination.len());
            destination[..to_write_len].copy_from_slice(&to_write[..to_write_len]);
            for _ in 0..to_write_len {
                self.tx_buffer_encrypted.pop_front().unwrap();
            }
            total_written += to_write_len;
            destination = &mut destination[to_write_len..];

            if to_write_len == 0 {
                break;
            }
        }

        // Call `try_finish` to check whether the handshake has finished.
        (self.try_finish(), total_written)
    }
}

impl fmt::Debug for HandshakeInProgress {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("HandshakeInProgress").finish()
    }
}

lazy_static::lazy_static! {
    static ref NOISE_PARAMS: snow::params::NoiseParams =
        "Noise_XX_25519_ChaChaPoly_SHA256".parse().unwrap();
}

/// Potential error during the noise handshake.
#[derive(Debug, derive_more::Display)]
pub enum HandshakeError {
    /// Error in the decryption state machine.
    Cipher(CipherError),
    /// Failed to decode the payload as the libp2p-extension-to-noise payload.
    PayloadDecode(PayloadDecodeError),
    /// Key passed as part of the payload failed to decode into a libp2p public key.
    InvalidKey,
    /// Received a payload as part of a handshake message when none was expected.
    UnexpectedPayload,
    /// Signature of the noise public key by the libp2p key failed.
    SignatureVerificationFailed,
}

/// Error while decoding data.
#[derive(Debug, derive_more::Display)]
pub struct CipherError(snow::Error);

/// Error while decoding the handshake.
#[derive(Debug, derive_more::Display)]
pub struct PayloadDecodeError(prost::DecodeError);
